<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello World!</title>
  <subtitle>Android 技术图谱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-23T07:37:24.079Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>行者</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跟着源码学设计：Glide框架及源码解析（三）</title>
    <link href="http://yoursite.com/2016/08/22/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/08/22/跟着源码学设计：Glide框架及源码解析（三）/</id>
    <published>2016-08-22T07:30:25.000Z</published>
    <updated>2016-08-23T07:37:24.079Z</updated>
    
    <content type="html"><![CDATA[<p>前言</p>
<p>近期研究了一下Glide的图片加载框架，在这里和大家分享一下。由于代码研读有限，难免有错误的地方，了解的童鞋还望指正。有疑问的同学，可以加博主QQ: 1404562848。</p>
<p>本篇是Glide框架及源码解析的第三篇，更多文章敬请关注后续文章。如果这篇文章对大家学习Glide有帮助，还望大家多多转载。（版权归作者所有，如有转发，请注明文章出处：<a href="https://xiaodanchen.github.io/archives/" target="_blank" rel="external">https://xiaodanchen.github.io/archives/</a> ）</p>
<p>往期文章：</p>
<p><a href="https://xiaodanchen.github.io/2016/08/19/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">跟着源码学设计：Glide框架及源码解析（一）</a><br><a href="https://xiaodanchen.github.io/2016/08/22/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">跟着源码学设计：Glide框架及源码解析（二）</a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Glide内存缓存机制"><a href="#Glide内存缓存机制" class="headerlink" title="Glide内存缓存机制"></a>Glide内存缓存机制</h3><p>在之前的两篇中我们剖析了Glide的生命周期绑定机制和Glide的请求管理机制。接下来按说应该讲到request实际请求资源并回调刷新界面这一块了，但是为了更好的理解Glide在这一块的设计，我先大致的讲一讲Glide的内存缓存和管理机制。<br>不同于其他常见网络加载框架只有LruCatch一种缓存机制，Glide内存为三级缓存（非常牛逼巧妙的设计）：</p>
<ul>
<li>LruResourceCache： 缓存最近使用过但是当前未使用的资源，LRU算法</li>
<li>ActiveResourceCache：缓存当前正在使用的资源（注意是弱引用）</li>
<li><p>BitmapPool：缓存所有被释放的图片，内存复用，LRU算法</p>
</li>
<li><p>LruResourceCache和ActiveResourceCache设计是为了尽可能的资源复用</p>
</li>
<li>BitmapPool的设计是为了尽可能的内存复用</li>
<li>这样的设计能够有效的避免内存的抖动和内存的开销，进一步减少了GC的频率，这也就是为啥Glide是一种体验流畅的加载框架。</li>
</ul>
<p>说的比较抽象，是不是懵逼了？别急，上图：</p>
<p><img src="/hello-world/img/MemoryCacheManager.png" alt="Glide内存缓存及管理机制"></p>
<ul>
<li>当我们需要显示某个资源时，Glide会先去查找LruResourceCache，找到了则将资源从LruResourceCache移除加入到ActiveResourceCache；</li>
<li>LruResourceCache找不到资源则查找ActiveResourceCache，找不到则查找BitmapPool。</li>
<li>如果在BitmapPool也找不到合适的资源，则会根据加载策略从硬盘或者网络加载资源。</li>
<li>资源文件（流）数据会被转换封装为Resource缓存入ActiveResourceCache和Request对象中。</li>
<li>Request的target会获取resource中引用的资源并展示。</li>
</ul>
<ul>
<li><p>当target的资源需要release时，resource会根据缓存策略被缓存到LruResourceCache，同时ActiveResourceCache中的弱引用会被删除。如果，该资源不能缓存到LruResourceCache，则资源将被recycle到BitmapPool。</p>
</li>
<li><p>当需要回收内存时（比如系统内存不足或者生命周期结束），LruResourceCache将根据LRU算法recycle一些resource到BitmapPool。</p>
</li>
<li><p>BitmapPool会根据缓存池的尺寸和recycled resource的缓存策略来缓存resource的bitmap。</p>
</li>
<li><p>BitmapPool会根据LRU算法和缓存池的尺寸来释放一些老旧资源。</p>
</li>
</ul>
<p>这样就完成了一个资源的完整的循环。</p>
<h3 id="BitmapPool的内存复用机制"><a href="#BitmapPool的内存复用机制" class="headerlink" title="BitmapPool的内存复用机制"></a>BitmapPool的内存复用机制</h3><p>知识储备：</p>
<ul>
<li>BitmapFactory.Options.inBitmap是AndroiD3.0新增的一个属性，如果设置了这个属性则会重用这个Bitmap的内存从而提升性能。</li>
<li>在SDK 11 -&gt; 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了</li>
</ul>
<h4 id="使用inbitmap前，内存占用情况"><a href="#使用inbitmap前，内存占用情况" class="headerlink" title="使用inbitmap前，内存占用情况"></a>使用inbitmap前，内存占用情况</h4><p><img src="/hello-world/img/inbitmap_null.png" alt="使用inbitmap前，内存占用情况"></p>
<h4 id="使用inbitmap后，内存占用情况"><a href="#使用inbitmap后，内存占用情况" class="headerlink" title="使用inbitmap后，内存占用情况"></a>使用inbitmap后，内存占用情况</h4><p><img src="/hello-world/img/inbitmap.png" alt="使用inbitmap后，内存占用情况"></p>
<p>下面看一下核心代码：Downsampler的downsampleWithSize()方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private Bitmap downsampleWithSize(MarkEnforcingInputStream is, RecyclableBufferedInputStream  bufferedStream,</div><div class="line">BitmapFactory.Options options, BitmapPool pool, int <span class="keyword">in</span>Width, int <span class="keyword">in</span>Height, int sampleSize,</div><div class="line">DecodeFormat decodeFormat) &#123;</div><div class="line">  // Prior to KitKat, the <span class="keyword">in</span>Bitmap size must exactly match the size of the bitmap we<span class="string">'re decoding.</span></div><div class="line">  Bitmap.Config config = getConfig(is, decodeFormat);</div><div class="line">  options.inSampleSize = sampleSize;</div><div class="line">  options.inPreferredConfig = config;</div><div class="line">  if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT &lt;= Build.VERSION.SDK_INT) &amp;&amp; shouldUsePool(is)) &#123;</div><div class="line">    int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);</div><div class="line">    int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);</div><div class="line">    // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.</div><div class="line">    setInBitmap(options, pool.getDirty(targetWidth, targetHeight, config));</div><div class="line">  &#125;</div><div class="line">  return decodeStream(is, bufferedStream, options);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</div><div class="line">private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) &#123;</div><div class="line">  if (Build.VERSION_CODES.HONEYCOMB &lt;= Build.VERSION.SDK_INT) &#123;</div><div class="line">  	options.inBitmap = recycled;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ActiveResourceCache的设计（怎么工作？为什么采用弱引用？）"><a href="#ActiveResourceCache的设计（怎么工作？为什么采用弱引用？）" class="headerlink" title="ActiveResourceCache的设计（怎么工作？为什么采用弱引用？）"></a>ActiveResourceCache的设计（怎么工作？为什么采用弱引用？）</h3><ul>
<li>从LruResourceCache找到的资源会被从LruResourceCache移入到ActiveResourceCache。这样就尽量将LruResourceCache中的资源从LRU算法中提高了优先级。</li>
<li>ActiveResourceCache缓存的是Resource的弱引用对象，这样在GC的时候就会被释放，从而避免了LruResourceCache内存的释放几率</li>
</ul>
<p>以上两点体现的设计思想非常巧妙，还请大家好好体会。体会不了？别急，博主再给你来张图：</p>
<p><img src="/hello-world/img/ActiveCache.png" alt="ActiveResourceCache的设计"></p>
<p>此处应该有掌声（绝对是精华）！！</p>
<p>最后总结一下：<br>Glide的内存管理设计非常巧妙，让博主我是叹为观止啊。</p>
<ul>
<li>BitmapPool对内存的复用，有效的减少了内吨抖动和内存操作带来的性能损耗（绝对精华！！）</li>
<li>LruResourceCache + ActiveResourceCache的设计方案更是牛逼的一塌糊涂啊（值得好好体会）</li>
<li>这种设计还有个好处：LruResourceCache中都是当前不在使用的资源，做整体的资源回收那叫一个酸爽。</li>
</ul>
<p>（本篇是Glide框架及源码解析的第三篇，更多文章敬请关注后续文章。版权归作者所有，如有转发，请注明文章出处：<a href="https://xiaodanchen.github.io/2016/08/22/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="external">原文链接</a>）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;近期研究了一下Glide的图片加载框架，在这里和大家分享一下。由于代码研读有限，难免有错误的地方，了解的童鞋还望指正。有疑问的同学，可以加博主QQ: 1404562848。&lt;/p&gt;
&lt;p&gt;本篇是Glide框架及源码解析的第三篇，更多文章敬请关注后续文章。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Glide" scheme="http://yoursite.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>跟着源码学设计：Glide框架及源码解析（二）</title>
    <link href="http://yoursite.com/2016/08/22/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/08/22/跟着源码学设计：Glide框架及源码解析（二）/</id>
    <published>2016-08-22T02:04:12.000Z</published>
    <updated>2016-08-23T07:38:07.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期研究了一下Glide的图片加载框架，在这里和大家分享一下。由于代码研读有限，难免有错误的地方，了解的童鞋还望指正。有疑问的同学，可以加博主QQ: 1404562848。<br>本篇是Glide框架及源码解析的第二篇，更多文章敬请关注后续文章。<br>如果这篇文章对大家学习Glide有帮助，还望大家多多转载。（版权归作者所有，如有转发，请注明文章出处：<a href="https://xiaodanchen.github.io/archives/" target="_blank" rel="external">https://xiaodanchen.github.io/archives/</a> ）</p>
<h4 id="往期文章："><a href="#往期文章：" class="headerlink" title="往期文章："></a>往期文章：</h4><p><a href="https://xiaodanchen.github.io/2016/08/19/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external"> 跟着源码学设计：Glide框架及源码解析（一）</a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Request管理机制"><a href="#Request管理机制" class="headerlink" title="Request管理机制"></a>Request管理机制</h3><p>在上一篇中我们剖析了Glide的生命周期绑定机制，这一篇我们紧接着Glide的处理流程来学习一下Glide的请求管理机制。<br>我们先来看一下Glide的最简单的使用代码示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ImageView ivImage = (ImageView) findViewById(R.id.ivImage);</div><div class="line">Glide.with(ivImage.getContext()) //获取RequestManager对象</div><div class="line">     .load(url); //设置Request对象需要的资源链接</div><div class="line">     .into(ivImage); //获取Request对象并绑定viewTarget -&gt; 发起网络请求</div></pre></td></tr></table></figure></p>
<p>该段代码十分简洁，但是内部实现的功能却十分的强大，比如：</p>
<ul>
<li>request的生命周期管理（如：退出或者隐藏了界面，需求就取消或暂停了）</li>
<li>viewTarget的生命周期管理</li>
<li>资源的复用和释放</li>
<li>灵活的配置（request的builder模式）</li>
</ul>
<p>针对这些问题，后面将会一一展开剖析。</p>
<h3 id="request及其生命周期管理"><a href="#request及其生命周期管理" class="headerlink" title="request及其生命周期管理"></a>request及其生命周期管理</h3><ul>
<li>通过上一篇的学习，我们知道了Glide内部生命周期接口为LifecycleListener</li>
<li>RequestManager具有生命周期（实现了LifecycleListener接口）</li>
<li>request由RequestManager的into()方法族获得</li>
<li>request的生命周期由RequestManager统一管理</li>
</ul>
<h3 id="RequestManager是如何生成request并管理request队列的？"><a href="#RequestManager是如何生成request并管理request队列的？" class="headerlink" title="RequestManager是如何生成request并管理request队列的？"></a>RequestManager是如何生成request并管理request队列的？</h3><p>老规矩，先上图：<br><img src="/hello-world/img/GlideRequestManager.png" alt="Glide请求管理机制类图"></p>
<ul>
<li>如图， RequestManager持有一个RequestTracker对象requestTracker。</li>
<li>requestTracker对象维护request的队列集合</li>
<li>RequestManager的load()函数用于获取GenericRequestBuilder对象（其实是子类对象）<ul>
<li>load()内部调用loadGeneric()方法，将requestTracker对象引用传递给GenericRequestBuilder类</li>
<li>load()实际调用GenericRequestBuilder.load()方法完成request的URL设置</li>
</ul>
</li>
<li>GenericRequestBuilder的into()方法是实际产生request和消费request的地方。<ul>
<li>GenericRequestBuilder的into(target)方法调用obtainReauest()获取到GenericRequest对象request，request与target相互绑定并被requestTracker维护。</li>
</ul>
</li>
</ul>
<p>下面看一下核心代码：GenericRequestBuilder的into(target)方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123;</div><div class="line">  Util.assertMainThread();</div><div class="line">  <span class="keyword">if</span> (target == null) &#123;</div><div class="line">  	throw new IllegalArgumentException(<span class="string">"You must pass in a non null Target"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</div><div class="line">  	throw new IllegalArgumentException(<span class="string">"You must first set a model (try #load())"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //因为target和request是相互绑定的，所以考虑到复用的情景时，可以先获取一下request</div><div class="line">  Request previous = target.getRequest();</div><div class="line">   </div><div class="line">  //previous != null说明target有复用，需要释放之前绑定的资源</div><div class="line">  //注意：request内部是绑定了资源的，这里还没有讲到，先知道这回事，后面会讲</div><div class="line">  <span class="keyword">if</span> (previous != null) &#123;</div><div class="line">    //释放资源，防内存泄漏</div><div class="line">    //这段代码是精华，需要好好体会：</div><div class="line">    //Glidek肯定支持view的复用（对吧？），那么复用的view资源是如何绑定和释放的？</div><div class="line">    //这里就是资源释放的地方（入口），资源在何时绑定会在后续的课程讲到。</div><div class="line">    previous.clear();</div><div class="line">    requestTracker.removeRequest(previous);</div><div class="line">    previous.recycle();</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  //获取需求对象（对象绑定了target）</div><div class="line">  Request request = buildRequest(target);</div><div class="line">  //target绑定需求</div><div class="line">  target.setRequest(request);</div><div class="line">  //因为target具有生命周期，即实现了LifecycleListener方法，所以将其注册给ActivityFragmentLifecycle统一管理（不知道是啥的去看上一篇文章）</div><div class="line">  lifecycle.addListener(target);</div><div class="line">  //将需求加入队列并执行需求</div><div class="line">  //注意是单线程</div><div class="line">  requestTracker.runRequest(request);</div><div class="line">  </div><div class="line">  <span class="built_in">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="request的生命周期管理："><a href="#request的生命周期管理：" class="headerlink" title="request的生命周期管理："></a>request的生命周期管理：</h3><ul>
<li>根据上文得知，request都被加入到requestTracker中来管理</li>
<li>requestTracker由RequestManager创建和管理</li>
<li>RequestManager具有生命周期</li>
</ul>
<p>下面让我们看看RequestManager在各个生命周期回调里都做了什么</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">onStart</span></span>() &#123;</div><div class="line">	resumeRequests();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">onStop</span></span>() &#123;</div><div class="line">	pauseRequests();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">	requestTracker.clearRequests();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void <span class="function"><span class="title">pauseRequests</span></span>() &#123;</div><div class="line">	Util.assertMainThread();</div><div class="line">	requestTracker.pauseRequests();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void <span class="function"><span class="title">resumeRequests</span></span>() &#123;</div><div class="line">	Util.assertMainThread();</div><div class="line">	requestTracker.resumeRequests();</div><div class="line">&#125;</div><div class="line">//下面的两个回调其实和request的关系没有那么直接，先放在这里留个印象    </div><div class="line">public void onTrimMemory(int level) &#123;</div><div class="line">	glide.trimMemory(level);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void <span class="function"><span class="title">onLowMemory</span></span>() &#123;</div><div class="line">	glide.clearMemory();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 代码很清楚了吧。细心的同学可能注意到了onTrimMemory(int level)和onLowMemory()，这俩货是系统在资源不足时调用的，说白了就是释放内存，具体怎么搞得，后续文章会专门讲到Glide的内存管理机制（也是精华）。</p>
<p>最后让我们看看requestTracker都干啥了吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">public class RequestTracker &#123;</div><div class="line">  private final Set&lt;Request&gt; requests = Collections.newSetFromMap(new WeakHashMap&lt;Request, Boolean&gt;());</div><div class="line"></div><div class="line">  @SuppressWarnings(<span class="string">"MismatchedQueryAndUpdateOfCollection"</span>)</div><div class="line">  private final List&lt;Request&gt; pendingRequests = new ArrayList&lt;Request&gt;();</div><div class="line"></div><div class="line">  private boolean isPaused;</div><div class="line"></div><div class="line">  /**</div><div class="line">  * Starts tracking the given request.</div><div class="line">  */</div><div class="line">  public void runRequest(Request request) &#123;</div><div class="line">    requests.add(request);</div><div class="line">    <span class="keyword">if</span> (!isPaused) &#123;</div><div class="line">    	request.begin();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">   		pendingRequests.add(request);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  // Visible <span class="keyword">for</span> testing.</div><div class="line">  void addRequest(Request request) &#123;</div><div class="line">  	requests.add(request);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  /**</div><div class="line">  * Stops tracking the given request.</div><div class="line">  */</div><div class="line">  public void removeRequest(Request request) &#123;</div><div class="line">  	requests.remove(request);</div><div class="line">  	pendingRequests.remove(request);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  /**</div><div class="line">  * Returns &#123;@code <span class="literal">true</span>&#125; <span class="keyword">if</span> requests are currently paused, and &#123;@code <span class="literal">false</span>&#125; otherwise.</div><div class="line">  */</div><div class="line">  public boolean <span class="function"><span class="title">isPaused</span></span>() &#123;</div><div class="line">  	<span class="built_in">return</span> isPaused;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  /**</div><div class="line">  * Stops any <span class="keyword">in</span> progress requests.</div><div class="line">  */</div><div class="line">  public void <span class="function"><span class="title">pauseRequests</span></span>() &#123;</div><div class="line">    isPaused = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (Request request : Util.getSnapshot(requests)) &#123;</div><div class="line">      <span class="keyword">if</span> (request.isRunning()) &#123;</div><div class="line">      	request.pause();</div><div class="line">      	pendingRequests.add(request);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">  * Starts any not yet completed or failed requests.</div><div class="line">  */</div><div class="line">  public void <span class="function"><span class="title">resumeRequests</span></span>() &#123;</div><div class="line">    isPaused = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (Request request : Util.getSnapshot(requests)) &#123;</div><div class="line">      <span class="keyword">if</span> (!request.isComplete() &amp;&amp; !request.isCancelled() &amp;&amp; !request.isRunning()) &#123;</div><div class="line">      	request.begin();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    pendingRequests.clear();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">  * Cancels all requests and clears their resources.</div><div class="line">  */</div><div class="line">  public void <span class="function"><span class="title">clearRequests</span></span>() &#123;</div><div class="line">    <span class="keyword">for</span> (Request request : Util.getSnapshot(requests)) &#123;</div><div class="line">    	request.clear();</div><div class="line">    &#125;</div><div class="line">    pendingRequests.clear();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">  * Restarts failed requests and cancels and restarts <span class="keyword">in</span> progress requests.</div><div class="line">  */</div><div class="line">  public void <span class="function"><span class="title">restartRequests</span></span>() &#123;</div><div class="line">    <span class="keyword">for</span> (Request request : Util.getSnapshot(requests)) &#123;</div><div class="line">      <span class="keyword">if</span> (!request.isComplete() &amp;&amp; !request.isCancelled()) &#123;</div><div class="line">        // Ensure the request will be restarted <span class="keyword">in</span> onResume.</div><div class="line">        request.pause();</div><div class="line">        <span class="keyword">if</span> (!isPaused) &#123;</div><div class="line">          request.begin();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          pendingRequests.add(request);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（本篇是Glide框架及源码解析的第二篇，更多文章敬请关注后续文章。版权归作者所有，如有转发，请注明文章出处：<a href="https://xiaodanchen.github.io/2016/08/19/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">原文链接</a>）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近期研究了一下Glide的图片加载框架，在这里和大家分享一下。由于代码研读有限，难免有错误的地方，了解的童鞋还望指正。有疑问的同学，可以加博
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Glide" scheme="http://yoursite.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>跟着源码学设计：Glide 框架及源码解析（一）</title>
    <link href="http://yoursite.com/2016/08/19/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/08/19/跟着源码学设计：Glide框架及源码解析（一）/</id>
    <published>2016-08-19T07:44:57.442Z</published>
    <updated>2016-08-23T07:38:31.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期研究了一下Glide的图片加载框架，在这里和大家分享一下。由于代码研读有限，难免有错误的地方，了解的童鞋还望指正。有疑问的同学，可以加博主QQ: 1404562848。<br>如果这篇文章对大家学习Glide有帮助，还望大家多多转载。<br>（本篇是Glide框架及源码解析的第一篇，更多文章敬请关注后续文章。版权归作者所有，如有转发，请注明文章出处：<a href="https://xiaodanchen.github.io/" target="_blank" rel="external">https://xiaodanchen.github.io/</a> ）</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Glide-简介"><a href="#Glide-简介" class="headerlink" title="Glide 简介"></a>Glide 简介</h3><p>Glide是一个性能优良的第三方网络图片加载框架，Google官方对其较为推荐。Glide的优良性能在节省内存和快速流畅加载方面具有较好体现。究其内部机制，发现其优良性能得益于以下几点：</p>
<ul>
<li>与使用环境生命周期相绑定：RequestManagerFragment &amp; SupportRequestManagerFragment</li>
<li>内存的三级缓存池：LruMemoryResources, ActiveResources, BitmapPool</li>
<li>内存复用机制：BitmapPool</li>
</ul>
<p>更多的关于Glide的介绍网上资料很多，在这里不再赘述，下文中将针对Glide的内部机制展开说明。</p>
<h3 id="为什么要绑定生命周期（有什么优点）？"><a href="#为什么要绑定生命周期（有什么优点）？" class="headerlink" title="为什么要绑定生命周期（有什么优点）？"></a>为什么要绑定生命周期（有什么优点）？</h3><ul>
<li>可以实现网络请求根据生命周期而暂停、执行、恢复、释放等</li>
<li>可以实现资源比如图片的自动释放</li>
<li>降低了内存的压力</li>
<li>降低了内存泄漏的风险</li>
</ul>
<h3 id="绑定原理"><a href="#绑定原理" class="headerlink" title="绑定原理"></a>绑定原理</h3><ul>
<li>原理的知识基础：Android中FragmentManager（简称fm）中的所有fragment（通过fm.add()添加进来）都与fm所处的context环境具有生命周期的绑定。例如：我们的activity中的fragment的生命周期自动通过activity的fm和activity的生命周期绑定。</li>
</ul>
<ul>
<li>Glide内部定义封装了RequestManagerFragment 和 SupportRequestManagerFragment两种fragment用来实现绑定。该两类Fragment不具有任何的界面和其他功能，通过入口传入的context获取到的fm绑定生命周期到context上。</li>
<li>Glide内部的生命周期绑定机制进一步通过基于xxxxRequestManagerFragment 的生命周期接口的回调实现。</li>
</ul>
<h3 id="话不多说，先来张类图"><a href="#话不多说，先来张类图" class="headerlink" title="话不多说，先来张类图"></a>话不多说，先来张类图</h3><p><img src="/hello-world/img/GlideLifeCycle.png" alt="Glide生命周期绑定机制类图"></p>
<h3 id="关键类：RequestManagerRetriever-单例模式-："><a href="#关键类：RequestManagerRetriever-单例模式-：" class="headerlink" title="关键类：RequestManagerRetriever(单例模式)："></a>关键类：RequestManagerRetriever(单例模式)：</h3><ul>
<li>根据context获取fm;</li>
<li>获取xxxxRequestManagerFragment实例</li>
<li>获取RequestManager实例</li>
<li>相互绑定xxxxRequestManagerFragment和RequestManager</li>
<li>xxxxRequestManagerFragment绑定到context生命周期</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Note: 根据context类型，获取fm</div><div class="line"> */</div><div class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</div><div class="line"> public RequestManager get(Activity activity) &#123;</div><div class="line">   <span class="keyword">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">     <span class="built_in">return</span> get(activity.getApplicationContext());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     assertNotDestroyed(activity);</div><div class="line">     android.app.FragmentManager fm = activity.getFragmentManager();</div><div class="line">     <span class="built_in">return</span> fragmentGet(activity, fm);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">/**</div><div class="line"> * Note: new RequestManager(context,lifecycle,RequestManagerTreeNode)中，绑定了lifecycle;</div><div class="line"> * current.setRequestManager(requestManager):requestManager绑定到fragment</div><div class="line"> */</div><div class="line"> @TargetApi(Build.VERSION_CODES.HONEYCOMB)</div><div class="line"> RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123;</div><div class="line">   RequestManagerFragment current = getRequestManagerFragment(fm);</div><div class="line">   RequestManager requestManager = current.getRequestManager();</div><div class="line">   <span class="keyword">if</span> (requestManager == null) &#123;</div><div class="line">     requestManager = new RequestManager(context, current.getLifecycle(),current.getRequestManagerTreeNode());</div><div class="line">     current.setRequestManager(requestManager);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">return</span> requestManager;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line">/**</div><div class="line"> * Note: fm.beginTransaction().add(current, FRAGMENT_TAG): fragment绑定context生命周期</div><div class="line"> */</div><div class="line"> @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</div><div class="line"> RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123;</div><div class="line">   RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</div><div class="line">   <span class="keyword">if</span> (current == null) &#123;</div><div class="line">     current = pendingRequestManagerFragments.get(fm);</div><div class="line">     <span class="keyword">if</span> (current == null) &#123;</div><div class="line">       current = new RequestManagerFragment();</div><div class="line">       pendingRequestManagerFragments.put(fm, current);</div><div class="line">       fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class="line">       handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">return</span> current;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="关键类：xxxxRequestManagerFragment-绑定context的生命周期"><a href="#关键类：xxxxRequestManagerFragment-绑定context的生命周期" class="headerlink" title="关键类：xxxxRequestManagerFragment(绑定context的生命周期)"></a>关键类：xxxxRequestManagerFragment(绑定context的生命周期)</h3><ul>
<li>内部绑定一个RequestManager对象;</li>
<li>内部绑定一个ActivityFragmentLifecycle对象</li>
<li>在生命周期的回调中调用ActivityFragmentLifecycle的相应生命周期方法</li>
<li>RequestManager通过注册到ActivityFragmentLifecycle的lifecycleListeners集合实现生命周期绑定</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">private final ActivityFragmentLifecycle lifecycle;</div><div class="line">private RequestManager requestManager;</div><div class="line"> </div><div class="line">public <span class="function"><span class="title">RequestManagerFragment</span></span>() &#123;</div><div class="line">	this(new ActivityFragmentLifecycle());</div><div class="line">&#125;</div><div class="line"> </div><div class="line">RequestManagerFragment(ActivityFragmentLifecycle lifecycle) &#123;</div><div class="line">	this.lifecycle = lifecycle;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">/**</div><div class="line">* Sets the current &#123;@link com.bumptech.glide.RequestManager&#125;.</div><div class="line">* @param requestManager The request manager to use.</div><div class="line">*/</div><div class="line">public void <span class="built_in">set</span>RequestManager(RequestManager requestManager) &#123;</div><div class="line">	this.requestManager = requestManager;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/**</div><div class="line">* 生命周期：Glide通过xxxxRequestManagerFragment的生命周期回调实现内部生命周期回调</div><div class="line">*/</div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">onStart</span></span>() &#123;</div><div class="line">  super.onStart();</div><div class="line">  lifecycle.onStart();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">onStop</span></span>() &#123;</div><div class="line">  super.onStop();</div><div class="line">  lifecycle.onStop();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@Override</div><div class="line">public void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">  super.onDestroy();</div><div class="line">  lifecycle.onDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关键类：ActivityFragmentLifecycle"><a href="#关键类：ActivityFragmentLifecycle" class="headerlink" title="关键类：ActivityFragmentLifecycle"></a>关键类：ActivityFragmentLifecycle</h3><ul>
<li>管理同一个xxxxRequestManagerFragment分支下的所有LifecycleListener（具有生命周期）</li>
<li>被xxxxRequestManagerFragment生命周期接口回调</li>
<li>遍历回调所有LifecycleListener生命周期接口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A &#123;@link com.bumptech.glide.manager.Lifecycle&#125; implementation <span class="keyword">for</span> tracking and notifying listeners of</div><div class="line"> * &#123;@link android.app.Fragment&#125; and &#123;@link android.app.Activity&#125; lifecycle events.</div><div class="line"> */</div><div class="line">class ActivityFragmentLifecycle implements Lifecycle &#123;</div><div class="line">    private final Set&lt;LifecycleListener&gt; lifecycleListeners =</div><div class="line">            Collections.newSetFromMap(new WeakHashMap&lt;LifecycleListener, Boolean&gt;());</div><div class="line">    private boolean isStarted;</div><div class="line">    private boolean isDestroyed;</div><div class="line">  </div><div class="line">    @Override</div><div class="line">    public void addListener(LifecycleListener listener) &#123;</div><div class="line">        lifecycleListeners.add(listener);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isDestroyed) &#123;</div><div class="line">            listener.onDestroy();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStarted) &#123;</div><div class="line">            listener.onStart();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            listener.onStop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    void <span class="function"><span class="title">onStart</span></span>() &#123;</div><div class="line">        isStarted = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class="line">            lifecycleListener.onStart();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    void <span class="function"><span class="title">onStop</span></span>() &#123;</div><div class="line">        isStarted = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class="line">            lifecycleListener.onStop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        isDestroyed = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</div><div class="line">            lifecycleListener.onDestroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关键类：RequestManager"><a href="#关键类：RequestManager" class="headerlink" title="关键类：RequestManager"></a>关键类：RequestManager</h3><ul>
<li>RequestManager被绑定于xxxxRequestManagerFragment</li>
<li>RequestManager实现了LifecycleListener接口</li>
<li>RequestManager注册给xxxxRequestManagerFragment的ActivityFragmentLifecycle</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) &#123;</div><div class="line">        this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,</div><div class="line"> RequestTracker requestTracker, ConnectivityMonitorFactory factory) &#123;</div><div class="line">   this.context = context.getApplicationContext();</div><div class="line">   this.lifecycle = lifecycle;</div><div class="line">   this.treeNode = treeNode;</div><div class="line">   this.requestTracker = requestTracker;</div><div class="line">   this.glide = Glide.get(context);</div><div class="line">   this.optionsApplier = new OptionsApplier();</div><div class="line"> </div><div class="line">  ConnectivityMonitor connectivityMonitor = factory.build(context,</div><div class="line">  new RequestManagerConnectivityListener(requestTracker));</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</div><div class="line">    new Handler(Looper.getMainLooper()).post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">      @Override</div><div class="line">      public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">          lifecycle.addListener(RequestManager.this);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">  	lifecycle.addListener(this);</div><div class="line">  &#125;</div><div class="line">  lifecycle.addListener(connectivityMonitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生命周期时序图"><a href="#生命周期时序图" class="headerlink" title="生命周期时序图"></a>生命周期时序图</h3><p><img src="/hello-world/img/GlideLifeCycleCallBack.png" alt="Glide生命周期绑定机制时序图"></p>
<p>（本篇是Glide框架及源码解析的第一篇，更多文章敬请关注后续文章。版权归作者所有，如有转发，请注明文章出处：<a href="https://xiaodanchen.github.io/2016/08/19/%E8%B7%9F%E7%9D%80%E6%BA%90%E7%A0%81%E5%AD%A6%E8%AE%BE%E8%AE%A1%EF%BC%9AGlide%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">原文链接</a>）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近期研究了一下Glide的图片加载框架，在这里和大家分享一下。由于代码研读有限，难免有错误的地方，了解的童鞋还望指正。有疑问的同学，可以加博
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Glide" scheme="http://yoursite.com/tags/Glide/"/>
    
  </entry>
  
</feed>
